#!/bin/bash
#
#   makepkg
#
#   Copyright (c) 2005 by Aurelien Foret <orelien@chez.com>
#   Copyright (c) 2005 by Judd Vinet <jvinet@zeroflux.org>
#   Copyright (c) 2005 by Christian Hamar <krics@linuxforum.hu>
#   Copyright (c) 2006 by Alex Smith <alex@alex-smith.me.uk>
#   Copyright (c) 2006 by Andras Voroskoi <voroskoi@frugalware.org>
#   Copyright (c) 2005, 2006, 2007, 2008, 2009, 2010 by Miklos Vajna <vmiklos@frugalware.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#   USA.
#

## bash's 'echo' is buggy and does not check on write() for errors
ECHO="/bin/echo"
startdir=`pwd`
PKGDEST=$startdir
USE_COLOR="n"

# Options
BUILDSCRIPT="./FrugalBuild"
CLEANUP=0
CLEANCACHE=0
CLEANCCACHE=""
DEP_BIN=0
DEP_SRC=0
DEP_SUDO=0
FORCE=0
GENSHA1=0
INSTALL=0
DOWNLOAD=""
NOBUILD=0
NOCCACHE=0
NODEPS=0
NOEXTRACT=0
NOSTRIP=0
RMDEPS=0
CHROOT=1
NOUP2DATE=0
NODOCS=0
TREE=""
CACHEURL=""

PACMAN="pacman-g2.static"
PACMAN_OPTS=

# compat functions. these are useful if one would like to use makepkg outside
# FST. if you want to modify these, please submit a patch again FST first

###
# * Fextract(): Extract archives. Parameter: file name to extract. Example:
# Fextract pacman.tar.gz.
###
Fextract() {
	local cmd file tmp
	file="${1}"
	tmp="$($ECHO "${file}" | tr 'A-Z' 'a-z')"
	case "${tmp}" in
		*.tar.bz2|*.tbz2)
		cmd="tar $_F_extract_taropts --use-compress-program=bzip2 -xf $file" ;;
		*.tar.gz|*.tar.z|*.tgz)
		cmd="tar $_F_extract_taropts --use-compress-program=gzip -xf $file" ;;
		*.tar.lzma)
		cmd="tar $_F_extract_taropts --use-compress-program=lzma -xf $file" ;;
		*.tar.xz)
		cmd="tar $_F_extract_taropts --use-compress-program=xz -xf $file" ;;
		*.tar)
		cmd="tar $_F_extract_taropts -xf $file" ;;
		*.zip|*.xpi)
		unziphack=1
		cmd="unzip -qqo $file" ;;
		*.cpio.gz)
		cmd="bsdtar -x -f $file" ;;
		*.cpio.bz2)
		cmd="bsdtar -x -f $file" ;;
		*.gz)
		cmd="gunzip -f $file" ;;
		*.bz2)
		cmd="bunzip2 -f $file" ;;
		*.lzma)
		cmd="unlzma -f $file" ;;
		*.xz)
		cmd="unxz -f $file" ;;
		*.7z)
		cmd="7z x $file" ;;
		*)
		cmd="" ;;
	esac
	if [ "$cmd" != "" ]; then
		msg2 "$cmd"
		$cmd
		ret=$?
		if [ $ret -ne 0 ]; then
			# unzip will return a 1 as a warning, it is not an error
			if [ "$unziphack" != "1" -o $ret -ne 1 ]; then
				error "Failed to extract ${file}"
				msg "Aborting..."
				Fdie
			fi
		fi
	fi
}

# Frugalware extensions to makepkg
[ -e /usr/lib/frugalware/fwmakepkg ] && . /usr/lib/frugalware/fwmakepkg

# repoman.conf for $fst_root
[ -f /etc/repoman.conf ] && source /etc/repoman.conf
[ -n "$repos" ] && TREE="$repos"

# makepkg configuration
[ -f /etc/makepkg.conf ] && source /etc/makepkg.conf

INFAKEROOT=
if [ "$1" = "-F" ]; then
	INFAKEROOT=1
	shift
fi

INCHROOT=
if [ "$1" = "--inchroot" ]; then
	INCHROOT=1
	shift
fi

### SUBROUTINES ###

plain() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "    \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "    $1" >&2
	fi
}
msg() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "\033[1;32m==>\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "==> $1" >&2
	fi
}

msg2() {
        if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
                $ECHO -e "   \033[1;34m->\033[1;0m \033[1;1m$1\033[1;0m" >&2
        else
                $ECHO "   -> $1" >&2
        fi
}

warning() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "\033[1;33m==> WARNING:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "==> WARNING: $1" >&2
	fi
}
error() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "\033[1;31m==> ERROR:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "==> ERROR: $1" >&2
	fi
}

strip_url() {
	$ECHO "$1" | sed 's|^.*://.*/||g'
}

checkdeps() {
	local missdep=""
	local deplist=""

	[ $# -gt 0 ] || return

	missdep=`$PACMAN $PACMAN_OPTS -T $*`
	ret=$?
	if [ "$ret" != "0" ]; then
		if [ "$ret" = "127" ]; then
			msg "Missing Dependencies:"
			msg ""
			nl=0
			for dep in $missdep; do
				$ECHO -ne "$dep " >&2
				if [ "$nl" = "1" ]; then
					nl=0
					$ECHO -ne "\n" >&2
					# add this dep to the list
					depname=`$ECHO $dep | sed 's|=.*$||' | sed 's|>.*$||' | sed 's|<.*$||'`
					deplist="$deplist $depname"
					continue
				fi
				nl=1
			done
			msg ""
		else
			error "$PACMAN returned a fatal error."
			exit 1
		fi
	fi
	$ECHO $deplist
}

handledeps() {
	local missingdeps=0
	local deplist="$*"
	local haveperm=0
	if [ \( "`id -u`" = "0" -a "$INFAKEROOT" != "1" \) -o "$DEP_SUDO" = 1 ]; then
		haveperm=1
	fi

	if [ "$deplist" != "" -a $haveperm -eq 1 ]; then
		if [ "$DEP_BIN" = "1" ]; then
			# install missing deps from binary packages (using pacman-g2 -S)
			msg "Installing missing dependencies..."
			if [ "$INCHROOT" != "1" -o "`check_option SCRIPTLET`" ]; then
				$PACMAN $PACMAN_OPTS -D $deplist
			else
				$PACMAN $PACMAN_OPTS --noscriptlet -D $deplist
			fi
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
		elif [ "$DEP_SUDO" = "1" ]; then
			# install missing deps from binary packages (using pacman-g2 -S and sudo)
			msg "Installing missing dependencies..."
			if [ "$INFAKEROOT" = "1" ]; then
				# kinda hacky, but we need to make pacman-g2 think that we're NOT
				# in fakeroot so it will go ahead and install the dependencies.
				FAKEROOTKEY2=$FAKEROOTKEY
				unset FAKEROOTKEY
			fi
			if [ "$INCHROOT" != "1" -o "`check_option SCRIPTLET`" ]; then
				sudo $PACMAN $PACMAN_OPTS -D $deplist
			else
				sudo $PACMAN $PACMAN_OPTS --noscriptlet -D $deplist
			fi
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
			if [ "$INFAKEROOT" = "1" ]; then
				export FAKEROOTKEY=$FAKEROOTKEY2
				unset FAKEROOTKEY2
			fi
		elif [ "$DEP_SRC" = "1" ]; then
			# install missing deps by building them from source.
			# we look for each package name in $fst_root and build it.
			if [ "$fst_root" = "" ]; then
				error "The fst_root environment variable is not defined, check your /etc/repoman.conf!"
				exit 1
			fi
			# TODO: handle version comparators (eg, glibc>=2.2.5)
			msg "Building missing dependencies..."
			for dep in $deplist; do
				candidates=`find $fst_root -type d -name "$dep"`
				if [ "$candidates" = "" ]; then
					error "Could not find \"$dep\" under $fst_root"
					exit 1
				fi
				success=0
				for pkgdir in $candidates; do
					if [ -f $pkgdir/$BUILDSCRIPT ]; then
						cd $pkgdir
						if [ "$RMDEPS" = "1" ]; then
							makepkg -i -c -b -r -w $PKGDEST
						else
							makepkg -i -c -b -w $PKGDEST
						fi
						if [ $? -eq 0 ]; then
							success=1
							break
						fi
					fi
				done
				if [ "$success" = "0" ]; then
					error "Failed to build \"$dep\""
					exit 1
				fi
			done
		else
			missingdeps=1
		fi
	elif [ "$deplist" != "" -a $haveperm -eq 0 ]; then
		if [ "$DEP_SRC" = "1" -o "$DEP_BIN" = "1" ]; then
			warning "Cannot auto-install missing dependencies as a normal user without sudo!"
			plain "Run makepkg as root or with -S to resolve dependencies automatically."
		fi
		missingdeps=1
	fi
	# rerun any additional sh scripts found in /etc/profile.d/
	for i in /etc/profile.d/*.sh
	do
		if [ -x $i ]; then
			. $i &>/dev/null
		fi
	done
	# some applications (eg, blackbox) will not build with some languages
	unset LC_ALL LANG

	return $missingdeps
}

usage() {
	$ECHO "makepkg"
	$ECHO
	$ECHO "Usage: $0 [options] [variable assignations]"
	$ECHO
	$ECHO "Options:"
	$ECHO "  -a, --searchdeps Search for package dependencies automatically"
	$ECHO "  -A <url>         rsync cache url to use before downloading anything"
	$ECHO "  -b, --builddeps  Build missing dependencies from source"
	$ECHO "  -B, --noccache   Do not use ccache during build"
	$ECHO "  -c, --clean      Clean up work files after build"
	$ECHO "  -C, --cleancache Clean up source files from the cache"
	$ECHO "  -d, --nodeps     Skip all dependency checks"
	$ECHO "  -D <pkgname>     Clean up the compiler cache for a package"
	$ECHO "  -e, --noextract  Do not extract source files (use existing src/ dir)"
	$ECHO "  -f, --force      Overwrite existing package"
	$ECHO "  -g, --gensha1    Generate SHA1sums for source files"
	$ECHO "  -G, --wrtsha1    Generate SHA1sums for source files and add it to the build script"
	$ECHO "  -h, --help       This help"
	$ECHO "  -i, --install    Install package after successful build"
	$ECHO "  -j <jobs>        Set MAKEFLAGS to \"-j<jobs>\" before building"
	$ECHO "  -l <pkgname>     Download buildscripts before building"
	$ECHO "  -m, --nocolor    Disable colorized output messages"
	$ECHO "  -n, --nostrip    Do not strip binaries/libraries"
	$ECHO "  -o, --nobuild    Download and extract files only"
	$ECHO "  -p <buildscript> Use an alternate build script (instead of $BUILDSCRIPT)"
	$ECHO "  -r, --rmdeps     Remove installed dependencies after a successful build"
	$ECHO "  -R, --chroot     Build the package in a chroot environment (default)"
	$ECHO "  -H, --host       Build the package on the host system"
	$ECHO "  -s, --syncdeps   Install missing dependencies with pacman-g2"
	$ECHO "  -S, --sudosync   Install missing dependencies with pacman-g2 and sudo"
	$ECHO "  -u, --noup2date  Do not check for newer version"
	$ECHO "  -t <tree>        Use the given tree's chroot to build in"
	$ECHO "  -w <destdir>     Write package to <destdir> instead of the working dir"
	$ECHO "  -z <compression> Use compression program for a package (instead of $PKG_COMP)"
	$ECHO
	$ECHO "These options can be passed to pacman-g2:"
	$ECHO
	$ECHO "  --noconfirm      Do not ask for confirmation when resolving dependencies"
	$ECHO "  --noprogressbar  Do not show a progress bar when downloading files"
	$ECHO
	$ECHO "If -p is not specified, makepkg will look for $BUILDSCRIPT"
	$ECHO "Variable assignations are user defined shell assignations (eg. USE_FOO=BAR) used to interact with makepkg and the FrugalBuilds."
	$ECHO
	$ECHO "Compatibility options (these may be removed in any future release):"
	$ECHO "  --gzip           Use gzip compression for a package"
}

chroot_umount() {
    msg "Attempting to umount chroot directories..."
    umount $CHROOTDIR/proc >/dev/null
    umount $CHROOTDIR/sys >/dev/null
    umount $CHROOTDIR/dev >/dev/null
    umount $CHROOTDIR/var/cache/pacman-g2 >/dev/null
    umount $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to umount chroot directories."
	exit 1
    fi
    msg "Successfully umounted chroot directories."
}

chroot_mount() {
    msg "Attempting to mount chroot directories..."
    mount -t proc none $CHROOTDIR/proc >/dev/null
    mount -t sysfs none $CHROOTDIR/sys >/dev/null
    mount -t devtmpfs none $CHROOTDIR/dev >/dev/null
    mount -o bind /var/cache/pacman-g2 $CHROOTDIR/var/cache/pacman-g2 >/dev/null
    mount -o bind $CCACHE_BASEDIR/$pkgname \
    $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to mount chroot directories."
	exit 1
    fi
    msg "Successfully mounted chroot directories."
}

chroot_lock() {
	if [ -e $CHROOTDIR/var/tmp/fst/lock -a -d /proc/$(cat $CHROOTDIR/var/tmp/fst/lock 2>/dev/null) ]; then
		error "Process $(cat $CHROOTDIR/var/tmp/fst/lock) is already building in this chroot."
		plain "If you know what you are doing, you"
		plain "can remove $CHROOTDIR/var/tmp/fst/lock."
		exit 1
	else
		echo $$ >$CHROOTDIR/var/tmp/fst/lock
	fi
}

chroot_unlock() {
	rm -f $CHROOTDIR/var/tmp/fst/lock $_F_makepkg_pacconf
}

chroot_clean()
{
	if [ "$CHROOT" = "1" ]; then
		$ECHO $CHROOTDIR |grep -q $TREE$ || CHROOTDIR="$CHROOTDIR/$TREE"
		if [ -d "$CHROOTDIR" ]; then
			chroot_lock
			msg "Removing unnecessary packages."
			for i in "$COREPKGS"
			do
				corelist="$corelist `/usr/sbin/chroot $CHROOTDIR $PACMAN -Sg $i |grep -v '^\w'`"
			done
			for i in `/usr/sbin/chroot $CHROOTDIR $PACMAN -Q|sed 's/\([^ ]*\) .*/\1/'`
			do
				if ! $ECHO $corelist |grep -qw $i; then
					removelist="$removelist $i"
				fi
			done
			if [ ! -z "$removelist" ]; then
				/usr/sbin/chroot $CHROOTDIR $PACMAN -Rcn $removelist --noconfirm
				if [ "$?" != "0" ]; then
					error "Failed to remove packages."
					exit 1
				fi
			fi
			msg "Cleaning chroot."
			rm -rf $CHROOTDIR/var/tmp/fst/*
		else
			error "$CHROOTDIR does not exist, can't clean a non-existing chroot."
			exit 1
		fi
	fi
}

create_pkg()
{
	msg "Generating files for $1:"
	# write the .PKGINFO file
	msg2 ".PKGINFO file... " >&2
	if [ "$1" = "$pkgname" ]; then
		cd $startdir/pkg
	else
		cd $startdir/pkg.$1
	fi
	size=`du -cb . | tail -n 1 | awk '{print $1}'`
	$ECHO "# Generated by makepkg" >.PKGINFO
	$ECHO -n "# " >>.PKGINFO
	date >>.PKGINFO
	$ECHO "pkgname = $1" >>.PKGINFO
	$ECHO "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	$ECHO "pkgdesc = $pkgdesc" >>.PKGINFO
	if [ -n "$pkgdesc_localized" ]; then
		for it in "${pkgdesc_localized[@]}"; do
			$ECHO "pkgdesc = $it" >>.PKGINFO
		done
	fi
	$ECHO "url = $url" >>.PKGINFO
	$ECHO "builddate = $builddate" >>.PKGINFO
	$ECHO "buildtype = $buildtype" >>.PKGINFO
	$ECHO "packager = $packager" >>.PKGINFO
	$ECHO "size = $size" >>.PKGINFO
	if [ "$CARCH" != "" ]; then
		$ECHO "arch = $CARCH" >>.PKGINFO
	fi

	for it in ${license[@]}; do
		$ECHO "license = $it" >>.PKGINFO
	done
	for it in ${replaces[@]}; do
		$ECHO "replaces = $it" >>.PKGINFO
	done
	for it in ${groups[@]}; do
		$ECHO "group = $it" >>.PKGINFO
	done
	for it in ${depends[@]}; do
		$ECHO "depend = $it" >>.PKGINFO
	done
	for it in ${rodepends[@]}; do
		$ECHO "depend = $it" >>.PKGINFO
	done
	for it in ${removes[@]}; do
		$ECHO "remove = $it" >>.PKGINFO
	done
	for it in ${conflicts[@]}; do
		$ECHO "conflict = $it" >>.PKGINFO
	done
	for it in ${provides[@]}; do
		$ECHO "provides = $it" >>.PKGINFO
	done
	for it in ${backup[@]}; do
		$ECHO "backup = $it" >>.PKGINFO
	done

	# check for an install script
	if [ "$install" == "" ]; then
		[ -e $startdir/$1.install ] && install=$1.install
	fi
	if [ "$install" != "" ]; then
		msg2 ".INSTALL file... " >&2
		if [ "`$ECHO $install |sed 's/^\(.\).*/\1/'`" = "/" ]; then
			cp $install .INSTALL
		else
			cp $startdir/$install .INSTALL
		fi
	fi

	if [ -f $startdir/Changelog ]; then
		msg2 ".CHANGELOG file... " >&2
		cp $startdir/Changelog .CHANGELOG
	fi

	# build a filelist
	msg2 ".FILELIST file... " >&2
	tar cvf /dev/null * | sort >.FILELIST

	# tar it up
	msg2 "Compressing $1-$pkgver-$pkgrel-$CARCH.$PKG_EXT " >&2
	unset extra
	if [ -f .INSTALL ]; then
		extra=".INSTALL"
	fi
	if [ -f .CHANGELOG ]; then
		extra="$extra .CHANGELOG"
	fi

	case "$COMPRESS_PROGRAM" in
	none)	tarargs="-cf" ;;
	*)	tarargs="--use-compress-program=$COMPRESS_PROGRAM -cf" ;;
	esac

	if [ "$INCHROOT" != "1" ]; then
		tar $tarargs $PKGDEST/$1-$pkgver-$pkgrel-$CARCH.$PKG_EXT .PKGINFO .FILELIST \
		$extra *
	else
		tar $tarargs ../$1-$pkgver-$pkgrel-$CARCH.$PKG_EXT .PKGINFO .FILELIST \
			$extra *
	fi

	if [ "$SEARCHDEPS" == "1" ]; then
		if [ -x /usr/bin/chkdep ]; then
			msg "Searching for depends..."
			warning "Do not use this information without thinking!"
			if [ -n "$_F_makepkg_chkdep" ]; then
				chkdep -m $_F_makepkg_chkdep -d ./ -n $1 -i
			else
				chkdep -d ./ -n $1 -i
			fi
		else
			warning "Chkdep is not installed and is required to search depends."
			plain "Install the pacman-tools package, which contains chkdep."
			plain ""
			sleep 1
		fi
	fi
}

strip_pkg()
{
	local dir="" subpkg=""
	if [ "$1" = "$pkgname" ]; then
		dir="$startdir/pkg"
	else
		dir="$startdir/pkg.$1"
		subpkg="subpackage "
	fi
	if [ ! "`check_option NOSTRIP`" -a "$NOSTRIP" = "0" ]; then
		msg "Stripping debugging symbols from libraries from $subpkg$1..."
		find $dir/{,usr,usr/local,opt/*}/lib -type f -not -name "*.dll" -not -name "*.exe" \
			-exec /usr/bin/strip --strip-debug '{}' \; 2>&1 \
			| grep -v "No such file" | grep -v "format not recognized"
		msg "Stripping symbols from binaries from $subpkg$1..."
		find $dir/{,usr,usr/local,opt/*}/{bin,sbin} -type f -not -name "*.dll" -not -name "*.exe" \
			-exec /usr/bin/strip '{}' \; 2>&1 \
			| grep -v "No such file" | grep -v "format not recognized"
	fi
}

in_array()
{
	local i
	needle=$1
	shift 1
	# array() undefined
	[ -z "$1" ] && return 1
	for i in $*
	do
		[ "$i" == "$needle" ] && return 0
	done
	return 1
}

install_pkg()
{
	if [ "$INSTALL" = "1" -a "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
		msg "Installing package(s) with $PACMAN -U..."
		targs="$PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT"
		if [ ! -z "$subpkgs" ]; then
			i=0
			for subpkg in "${subpkgs[@]}"
			do
				targs="$targs $PKGDEST/${subpkg}-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT"
			done
		fi
		$PACMAN $PACMAN_OPTS -U $targs || exit $?
	elif [ "$INSTALL" = "1" -a "$DEP_SUDO" = "1" ]; then
		msg "Installing package(s) with sudo $PACMAN -U..."
		targs="$PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT"
		if [ ! -z "$subpkgs" ]; then
			i=0
			for subpkg in "${subpkgs[@]}"
			do
				targs="$targs $PKGDEST/${subpkg}-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT"
			done
		fi
		if [ "$INFAKEROOT" = "1" ]; then
			FAKEROOTKEY2=$FAKEROOTKEY
			unset FAKEROOTKEY
		fi
		sudo $PACMAN $PACMAN_OPTS -U $targs || exit $?
		if [ "$INFAKEROOT" = "1" ]; then
			export FAKEROOTKEY=$FAKEROOTKEY2
			unset FAKEROOTKEY2
		fi
	elif [ "$INSTALL" = "1" ]; then
		warning "Cannot auto-install packages as a normal user without sudo!"
		plain "Run makepkg as root or with -S to install packages automatically."
	fi
	exit 0
}

if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
	if [ "$(/usr/bin/tput colors)" -lt 3 ]; then
		USE_COLOR="n"
		warning "Disabling color as the terminal does not support it."
	fi 
fi

if [ -z "$PKG_EXT" ]; then
	error "The PKG_EXT environment variable is not defined, check your /etc/makepkg.conf!"
	exit 1
fi

if [ -z "$PKG_COMP" ]; then
	error "The PKG_COMP environment variable is not defined, check your /etc/makepkg.conf!"
	exit 1
fi

if [ "$USE_AUTO_MAKEFLAGS" != "n" ]; then
	export MAKEFLAGS="-j`grep -c ^processor /proc/cpuinfo`"
fi

ARGLIST=$@
COMPRESS_PROGRAM="$PKG_COMP"

while [ "$#" -ne "0" ]; do
	case $1 in
# pacman-g2
		--noconfirm)      PACMAN_OPTS="$PACMAN_OPTS --noconfirm" ;;
		--noprogressbar)  PACMAN_OPTS="$PACMAN_OPTS --noprogressbar" ;;
# makepkg
		--searchdeps) SEARCHDEPS=1 ;;
		--clean)      CLEANUP=1 ;;
		--cleancache) CLEANCACHE=$(($CLEANCACHE+1)) ;;
		--syncdeps)   DEP_BIN=1 ;;
		--sudosync)   DEP_SUDO=1 ;;
		--builddeps)  DEP_SRC=1 ;;
		--noccache)   NOCCACHE=1 ;;
		--nodeps)     NODEPS=1 ;;
		--noextract)  NOEXTRACT=1 ;;
		--install)    INSTALL=1 ;;
		--force)      FORCE=1 ;;
		--nostrip)    NOSTRIP=1 ;;
		--nobuild)    NOBUILD=1 ;;
		--nocolor)    USE_COLOR="n" ;;
		--gensha1)    GENSHA1=1; CHROOT=0 ;;
		--wrtsha1)    GENSHA1=1; WRITESHA1=1; CHROOT=0; NODEPS=1 ;;
		--rmdeps)     RMDEPS=1 ;;
		--chroot)     CHROOT=1 ;;
		--host)       CHROOT=0 ;;
		--noup2date)  NOUP2DATE=1 ;;
		--gzip)       COMPRESS_PROGRAM="gzip" ;;
		--help)
			usage
			exit 0
			;;
		--*)
			usage
			exit 1
			;;
		-*)
			while getopts "aA:bBcCdD:efgGhij:kl:Lmnop:urRHsSt:w:z:-" opt; do
				case $opt in
					a) SEARCHDEPS=1 ;;
					A) CACHEURL=$OPTARG ;;
					b) DEP_SRC=1 ;;
					B) NOCCACHE=1 ;;
					c) CLEANUP=1 ;;
					C) CLEANCACHE=$(($CLEANCACHE+1)) ;;
					d) NODEPS=1 ;;
					D) CLEANCCACHE=$OPTARG ;;
					e) NOEXTRACT=1 ;;
					f) FORCE=1 ;;
					g) GENSHA1=1; CHROOT=0 ;;
					G) GENSHA1=1; WRITESHA1=1; CHROOT=0; NODEPS=1 ;;
					h)
						usage
						exit 0
						;;
					i) INSTALL=1 ;;
					j) export MAKEFLAGS="-j$OPTARG" ;;
					l) DOWNLOAD="$OPTARG" ;;
					m) USE_COLOR="n" ;;
					n) NOSTRIP=1 ;;
					o) NOBUILD=1; CHROOT=0 ;;
					p) BUILDSCRIPT=$OPTARG ;;
					r) RMDEPS=1 ;;
					R) CHROOT=1 ;;
					H) CHROOT=0 ;;
					s) DEP_BIN=1 ;;
					S) DEP_SUDO=1 ;;
					t) TREE="$OPTARG" ;;
					u) NOUP2DATE=1 ;;
					w) PKGDEST=$OPTARG ;;
					z) COMPRESS_PROGRAM=$OPTARG ;;
					-)
						OPTIND=0
						break
						;;
					*)
						usage
						exit 1
						;;
				esac
			done
			;;
		*=*)	eval $(IFS= ; printf 'export %q=%q' "${1%%=*}" "${1#*=}")
			;;
		*)
			true
			;;
	esac
	shift
done

# see if we need to append bases to $TREE
if ! echo $TREE |grep -q ,; then
	# only parse _bases if they were no provided on the commandline
	bases=$(eval "echo \$${TREE}_bases")
	[ -n "$bases" ] && TREE="$TREE,$bases"
fi

# check for COMPRESS_PROGRAM program to be in the path
if [ -z "`which $COMPRESS_PROGRAM 2>/dev/null`" ]; then
	error "Cannot find compress program ($COMPRESS_PROGRAM) in PATH"
	exit 1
fi

# check for sudo
if [ "$DEP_SUDO" = "1" -a ! "`type -p sudo`" ]; then
	error "Cannot find the sudo binary! Is sudo installed?"
	exit 1
fi

# convert a (possibly) relative path to absolute
cd $PKGDEST 2>/dev/null
if [ $? -ne 0 ]; then
	error "Package destination directory does not exist or permission denied."
	exit 1
fi
PKGDEST=`pwd`
cd $OLDPWD

if [ -z $CCACHE_BASEDIR ]; then
	export CCACHE_BASEDIR=/var/cache/ccache
fi

if [ ! -z "$CLEANCCACHE" ]; then
	export CCACHE_DIR=$CCACHE_BASEDIR/$CLEANCCACHE
	ccache -C
	exit 0
fi

if [ "$INCHROOT" = "1" ]; then
	$ECHO $$ >lock
fi

if [ $CLEANCACHE -ge 1 ]; then
	if [ $CLEANCACHE -ge 2 ]; then
		msg "Cleaning up the compiler cache."
		export CCACHE_DIR=$CCACHE_BASEDIR
		ccache -C
	fi
	if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
		if [ $CLEANCACHE -ge 2 ]; then
			msg "Cleaning up source files from the cache."
			rm -rf /var/cache/pacman-g2/src/*
		fi
		chroot_clean
		for i in `grep $CHROOTDIR /proc/mounts|sed 's/^[^ ]* \([^ ]*\) .*/\1/'`
		do
			umount $i
		done
		if [ "$CLEANUP" = "1" ]; then
			if [ -z "`grep $CHROOTDIR /proc/mounts`" ]; then
				msg "Removing the chroot."
				rm -rf $CHROOTDIR
			else
				error "Failed to umount some bind mounts, can't remove the chroot."
			fi
		fi
		exit 0
	else
		error "You must be root to clean the cache."
		exit 1
	fi
fi

unset pkgname pkgver pkgrel pkgdesc url license groups provides force
unset replaces depends removes conflicts backup source install makedepends
unset rodepends options pkdesc_localized
for i in `set|grep ^_F_|sed 's/\(=.*\| ()\)//'`; do unset $i; done
umask 0022

# download buildscript if necessary
if [ ! -z "$DOWNLOAD" -a "$INFAKEROOT" != "1" ]; then
	msg "Retrieving $DOWNLOAD's buildscript..."

	# find the package
	if ! $PACMAN -Si $DOWNLOAD >/dev/null 2>&1; then
		error "Package \"$DOWNLOAD\" was not found."
		exit 1
	fi

	# check for a download utility
	if [ -z "$FTPAGENT" ]; then
		error "FTPAGENT is not configured. Check the /etc/makepkg.conf file."
		msg "Aborting..."
		exit 1
	fi
	ftpclient=`$ECHO $FTPAGENT | awk {'print $1'}`
	if [ ! -x $ftpclient ]; then
		error "ftpclient `basename $ftpclient` is not installed."
		msg "Aborting..."
		exit 1
	fi

	confs=`cat /etc/pacman-g2.conf |grep ^Include|sed 's/.* = \(.*\)/\1/'`

	# searching for a mirror
	repo=`$PACMAN -Si $DOWNLOAD |grep ^Repo |sed -n 's/.* \([^ ]*\)/\1/;1 p'`
	dir=`grep ^Server /etc/pacman-g2/repos/$repo |sed -n 's/.* = \(.*\)/\1/;1 p'`
	arch=`grep ^Server /etc/pacman-g2/repos/$repo |sed -n 's/.*-\(.*\)/\1/;1 p'`
	cat=`$PACMAN -Si $DOWNLOAD |grep ^G |sed 's/.* : \([^ ]*\) .*/\1/;'`
	dlpath="$dir/../"

	# download the script
	mkdir $DOWNLOAD
	cd $DOWNLOAD
	# FIXME: apps other than wget may not support -m and/or -l
	$FTPAGENT -m -l 1 $dlpath/source/$cat/$DOWNLOAD/ 2>&1
	if [ ! -f $file ]; then
		error "Failed to download $file"
		msg "Aborting..."
		exit 1
	fi
	junk=`$ECHO $dir|sed "s|^.*://\(.*\)/frugalware-$arch|\1/$quickdl|"`/source/$cat/$DOWNLOAD/
	mv $junk* ./
	rm -rf `$ECHO $junk|cut -d/ -f1`
	for i in `find * -type d`
	do
		( cd $i && [ -e .listing ] && rm .listing )
	done
fi

if [ "$PACKAGER" != "" ]; then
	packager="$PACKAGER"
else
	error "Please make sure that you edit /etc/makepkg.conf and set the PACKAGER= variable"
	exit 1
fi
if [ -z "$PKG_EXT" ]; then
	error "Please make sure that you edit /etc/makepkg.conf and set the PKG_EXT= variable"
	exit 1
fi
if [ ! -f $BUILDSCRIPT ]; then
	error "$BUILDSCRIPT does not exist."
	exit 1
fi

source ./$BUILDSCRIPT

# check for no-no's
if [ -z "$pkgver" ]; then
	error "pkgver is not allowed to be empty."
	exit 1
fi
if [ -z "$pkgrel" ]; then
	error "pkgrel is not allowed to be empty."
	exit 1
fi
if [ `$ECHO $pkgver | grep '-'` ]; then
	error "pkgver is not allowed to contain hyphens."
	exit 1
fi
if [ `$ECHO $pkgrel | grep '-'` ]; then
	error "pkgrel is not allowed to contain hyphens."
	exit 1
fi
if ! in_array $CARCH ${archs[@]}; then
	error "$pkgname is not available on $CARCH."
	exit 1
fi

if [ "`type -p fblint`" ]; then
	if ! fblint -p $BUILDSCRIPT &>/dev/null; then
		warning "fblint says some needed variables are missing or incomplete."
		plain "Abort the build unless you know what you are doing."
	fi
fi

eval "serverlist=${TREE}_servers"
if [ "$F_makepkg_scm" = "git" -a ! "`check_option NOVERSRC`" ]; then
	_serverlist=`GIT_DIR=$fst_root/${TREE}/.git git config --get remote.origin.url 2>/dev/null`
	if [ -n "$_serverlist" -a "${_serverlist:0:6}" != "git://" ]; then
		serverlist=$_serverlist
	fi
else
if [ -f "$fst_root/${TREE}/_darcs/prefs/defaultrepo" ]; then
	serverlist="`cat $fst_root/${TREE}/_darcs/prefs/defaultrepo`"
fi
fi
if [ -z "$CACHEURL" ]; then
	CACHEURL="${serverlist}/source/$groups/$pkgname"
fi

if [ ! -z "$subpkgs" ]; then
	goodsubpkgs=1
	if [ "${#subdescs[@]}" != 0 ] && [ "${#subdescs[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subdescs_localized[@]}" != 0 ] && [ "${#subdescs_localized[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#sublicense[@]}" != 0 ] && [ "${#sublicense[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subreplaces[@]}" != 0 ] && [ "${#subreplaces[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subgroups[@]}" != 0 ] && [ "${#subgroups[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subdepends[@]}" != 0 ] && [ "${#subdepends[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subrodepends[@]}" != 0 ] && [ "${#subrodepends[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subremoves[@]}" != 0 ] && [ "${#subremoves[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subconflicts[@]}" != 0 ] && [ "${#subconflicts[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subprovides[@]}" != 0 ] && [ "${#subprovides[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subbackup[@]}" != 0 ] && [ "${#subbackup[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subinstall[@]}" != 0 ] && [ "${#subinstall[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#suboptions[@]}" != 0 ] && [ "${#suboptions[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subarchs[@]}" != 0 ] && [ "${#subarchs[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ $goodsubpkgs -ne 1 ]; then
		error "Subpackage infos are incomplete. Cannot create subpackages."
		exit 1
	fi

	makedepends=${makedepends[@]}
	for i in $(seq 0 $((${#subpkgs[@]} - 1)))
	do
		makedepends="$makedepends ${subdepends[$i]}"
	done
	makedepends=( $makedepends )
fi

if [ ! -e "$install" -a ! -e "$startdir/$install" -a ! "`check_option GENSCRIPTLET`" ]; then
	error "Missing install scriptlet. If this is intentional, add 'genscriptlet' to options()."
	exit 1
fi

if [ -f $PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT -a "$FORCE" = "0" -a "$GENSHA1" = "0" ]; then
	if [ "$INSTALL" = "1" ]; then
		warning "a package has already been built, installing existing package."
		install_pkg
	else
		error "a package has already been built.  (use -f to overwrite)"
		exit 1
	fi
fi

# Generate the Changelog if necessary.
indir=n
if [ "$F_makepkg_scm" = "git" ]; then
	git rev-parse --git-dir &>/dev/null && indir=y
elif [ "$F_makepkg_scm" = "darcs" ]; then
	darcs --commands 2>&1|grep -q add && indir=y
elif [ "$F_makepkg_scm" = "svn" ]; then
	svn info $BUILDSCRIPT &>/dev/null && indir=y
fi
if [ "$indir" = "y" ] && [ "$GENSHA1" = "0" -a "$NOBUILD" = "0" ]; then
	if [ ! -e Changelog ] || [ `stat -c %Y Changelog|sed 's/\..*//'` -lt `stat -c %Y $BUILDSCRIPT|sed 's/\..*//'` ]; then
		msg "Generating the Changelog..."
		if [ "$F_makepkg_scm" = "git" ]; then
			git log $BUILDSCRIPT >Changelog
		elif [ "$F_makepkg_scm" = "darcs" ]; then
			darcs changes $BUILDSCRIPT | \
				sed "s|\(.*\)source/\(.*\)/$BUILDSCRIPT\(.*\)|\1\2\3|;/Can't find changes prior to:/,\$d" \
				>Changelog
		elif [ "$F_makepkg_scm" = "svn" ]; then
			svn log $BUILDSCRIPT >Changelog
		fi
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %u:%g $BUILDSCRIPT` \
				Changelog
		fi
	fi
fi
# some applications (eg, blackbox) will not build with some languages
unset LC_ALL LANG
# Build chroot environment if necessary.
if [ "$CHROOT" = "1" -a "$INCHROOT" != "1" ]; then
	if [ "`id -u`" != 0 ]; then
		error "Building in a chroot as an unprivileged user is not possible."
		exit 1
	fi
	if [ "$CHROOTDIR" = "" ]; then
		error "The CHROOTDIR environment variable is not defined."
		exit 1
	fi
	CHROOTDIR="$CHROOTDIR/$TREE"

	mkdir -p $CHROOTDIR/{dev,etc,proc,sys,var/cache/pacman-g2,var/tmp/fst}

	chroot_lock

	install -d -m 2775 {$CCACHE_BASEDIR,$CHROOTDIR/var/cache/ccache}/$pkgname

	chroot_mount

	if [ ! -d "$CHROOTDIR/usr" -o ! -e "$CHROOTDIR/etc/pacman-g2.conf" ]; then
		msg "Building a '-$TREE' chroot environment"
		_F_makepkg_pacconf=`mktemp`
		cat /etc/pacman-g2.conf |grep -v Include >$_F_makepkg_pacconf
		for i in `$ECHO $TREE|sed 's/,/ /g'`
		do
			repo=$(eval "$ECHO \${${i}_$DB_EXT/.$DB_EXT}")
			[ -z "$repo" ] && repo="$i"
			# the config parser doesn't know about -r, so we
			# need $CHROOTDIR here for this first run
			$ECHO "Include = $CHROOTDIR/etc/pacman-g2/repos/$repo" >>$_F_makepkg_pacconf
		done
		mkdir -p $CHROOTDIR/{tmp,var/log,etc/pacman-g2/repos}
		cp -pf /etc/pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
		if [ -d ~/.pacman-g2/repos ]; then
			cp -pf ~/.pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
		fi
		$PACMAN -r "$CHROOTDIR" -Syf $COREPKGS --noconfirm --config $_F_makepkg_pacconf
		if [ "$?" != "0" ]; then
			error "Failed to build chroot environment."
			chroot_umount
			chroot_unlock
			exit 1
		fi
		cat $_F_makepkg_pacconf > $CHROOTDIR/etc/pacman-g2.conf
		# later runs use 'chroot pacman-g2' instead of
		# 'pacman-g2 -r', so get rid of $CHROOTDIR
		sed -i "s|$CHROOTDIR||" $CHROOTDIR/etc/pacman-g2.conf
		rm -f $_F_makepkg_pacconf
	else
		msg "Updating the '-$TREE' chroot environment"
		# copy these before any update since without them we can't even reach the servers
		cp -pf /etc/{resolv.conf,services} $CHROOTDIR/etc
		# run pacman-g2 -Su twice in case pacman-g2 updated
		yes "" | /usr/sbin/chroot "$CHROOTDIR" $PACMAN -Sy pacman-g2 --ask 94 && \
			/usr/sbin/chroot "$CHROOTDIR" $PACMAN -Su --noconfirm
		if [ "$?" != "0" ]; then
			error "Failed to update chroot environment."
			chroot_umount
			chroot_unlock
			exit 1
		fi
	fi
	# why is this necessary?
	chmod 1777 $CHROOTDIR/{var,}/tmp

	msg "Copying config files to chroot"
	cp -pf /etc/pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
	if [ -d ~/.pacman-g2/repos ]; then
		cp -pf ~/.pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
	fi
	# mtab can be removed once Frugalware-1.4 is out
	for i in makepkg.conf resolv.conf passwd shadow group fstab mtab
	do
		if [ -h $CHROOTDIR/etc/$i ]; then
			# it's a symlink, don't touch it
			continue
		fi
		cp -pf /etc/$i $CHROOTDIR/etc >/dev/null
		if [ -e $HOME/.$i ]; then
			cp $HOME/.$i $CHROOTDIR/etc/$i >/dev/null
		fi
	done
	chmod 644 $CHROOTDIR/etc/sudoers
	$ECHO "fst ALL=(ALL)       NOPASSWD: ALL" >$CHROOTDIR/etc/sudoers
	chmod 440 $CHROOTDIR/etc/sudoers
	chmod 644 $CHROOTDIR/etc/pacman-g2.conf
	cp -Ppf /etc/localtime $CHROOTDIR/etc >/dev/null
	cp -pf /etc/services $CHROOTDIR/etc > /dev/null
	if [ "$?" != "0" ]; then
		error "An error occurred while attempting to copy config files to chroot."
		chroot_umount
		exit 1
	fi
	# to make Finclude work
	[ -d $CHROOTDIR/var/tmp/fst/include/ ] || mkdir -p $CHROOTDIR/var/tmp/fst/include/
	if [ -d $Fincdir ]; then
		cp $Fincdir/* $CHROOTDIR/var/tmp/fst/include/
	fi

	msg "Copying $pkgname's buildscript to chroot"
	cp -a * $CHROOTDIR/var/tmp/fst/
	chown -R fst:users $CHROOTDIR/var/tmp/fst

	if [ ! -x  /usr/sbin/chroot ]; then
		error "chroot was not found."
	else
		msg "Entering chroot environment"
		BUILDLOG=${startdir}/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log
		if [ ! "`check_option NOFAKEROOT`" ]; then
			# add the fst user in case the host system is not a Frugalware one
			if ! getent passwd fst >/dev/null; then
				echo "fst:x:19:2::/var/tmp/fst:" >> $CHROOTDIR/etc/passwd
			fi
			# add fst to the ccache group if necessary
			if ! getent group ccache|grep -q fst; then
				/usr/sbin/chroot $CHROOTDIR \
					/usr/sbin/usermod -a -G ccache fst
			fi
			/usr/sbin/chroot $CHROOTDIR /usr/sbin/pwconv
			/usr/sbin/chroot $CHROOTDIR \
				/bin/su - fst -c "fakeroot -- $0 -F --inchroot -S $ARGLIST"
		else
			$ECHO "cd /var/tmp/fst/; $0 --inchroot -s $ARGLIST" | \
				/usr/sbin/chroot $CHROOTDIR /bin/su - -c /bin/sh
		fi 2>&1 | tee $BUILDLOG
		if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
			# remove colors
			sed -i "s|.[1;[0-9]\+m||g" $BUILDLOG
		fi
	fi

	if [ "`id -u`" = "0" ]; then
		chown `stat -c %u:%g $BUILDSCRIPT` \
			${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log
	fi

	if [ -f $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT ]; then
		mv $CHROOTDIR/var/tmp/fst/*-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT $PKGDEST
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %u:%g $BUILDSCRIPT` \
				*-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT
		fi
		# copy back the buildscript, maybe modified
		cp $CHROOTDIR/var/tmp/fst/$BUILDSCRIPT ./
		if [ "$CLEANUP" != "1" ]; then
			mv $CHROOTDIR/var/tmp/fst/{pkg,src,pkg.*} ./ 2> /dev/null
			chown -R `stat -c %u:%g $BUILDSCRIPT` pkg src pkg.* 2> /dev/null
		fi
		rm -rf $CHROOTDIR/var/tmp/fst/*
		chroot_clean
		# check optimization and write it to $BUILDSCRIPT
		msg "Checking for optimization..."
		if grep -q -- "\($CFLAGS\|$CXXFLAGS\)" "${BUILDLOG}" ; then
			if ! grep -q "# optimization" "${BUILDSCRIPT}" ; then
				$ECHO -e "\n# optimization OK" >> "${BUILDSCRIPT}"
			fi
		else
			warning "This package isn't ${CARCH}-optimized!"
		fi
		# copy build log to LOGDIR if set
		if [ -d "$LOGDIR" ]; then
			msg "Creating permanent copy of build log"
			cp "${BUILDLOG}" "${LOGDIR}/${LOGDIR_APPEND}-${pkgname}-${pkgver}-${pkgrel}.log"
		fi
		ret=0
	else
		ret=1
	fi

	chroot_umount
	chroot_unlock
	exit $ret
fi

# Enter the fakeroot environment if necessary.  This will call the makepkg script again
# as the fake root user.  We detect this by passing a sentinel option (-F) to makepkg
if [ "`id -u`" != "0" ]; then
	if [ "$USE_FAKEROOT" = "y" -o "$USE_FAKEROOT" = "Y" ]; then
		if [ `type -p fakeroot` ]; then
			msg "Entering fakeroot environment"
			if [ "$INCHROOT" != "1" ]; then
				fakeroot -- $0 -F $ARGLIST
			else
				fakeroot -- $0 -F --inchroot $ARGLIST
			fi
			exit $?
		else
			warning "Fakeroot is not installed.  Building as an unprivileged user"
			plain "will result in non-root ownership of the packaged files."
			plain "Install the fakeroot package to correctly build as a non-root"
			plain "user."
			plain ""
			sleep 1
		fi
	else
		warning "Running makepkg as an unprivileged user will result in non-root"
		plain "ownership of the packaged files.  Try using the fakeroot"
		plain "environment.  (USE_FAKEROOT=y in makepkg.conf)"
		plain ""
		sleep 1
	fi
fi

msg "Making package: $pkgname $pkgver-$pkgrel (`date`)"

unset deplist makedeplist
if [ `type -p $PACMAN` -a "$NODEPS" = "0" ]; then
	msg "Checking Buildtime Dependencies..."
	makedeplist=`checkdeps ${makedepends[@]}`
	handledeps $makedeplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
	# check deps again to make sure they were resolved
	deplist=`checkdeps ${makedepends[@]}`
	if [ ! -z "$deplist" ]; then
		error "Failed to install missing buildtime dependencies."
		exit 1
	fi
	msg "Checking Runtime Dependencies..."
	deplist=`checkdeps ${depends[@]}`
	handledeps $deplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
	# check deps again to make sure they were resolved
	deplist=`checkdeps ${depends[@]}`
	if [ ! -z "$deplist" ]; then
		error "Failed to install missing dependencies."
		exit 1
	fi
elif [ "$NODEPS" = "1" ]; then
	warning "skipping dependency checks."
else
	warning "$PACMAN was not found in PATH. skipping dependency checks."
fi

cd $startdir

# version checking
if [ "$NOUP2DATE" = "0" ]; then
	msg "Checking for newer version..."
	if $ECHO "$up2date"|grep -q " "; then
		cmd=`$ECHO "$up2date"|sed 's/^\([^ ]*\) .*/\1/'`
		if type -p $cmd &>/dev/null; then
			up2date=`eval "$up2date"`
		else
			warning "The $cmd program is missing.  Cannot check for newer version!"
			up2date=""
			sleep 1
		fi
	fi
	if [ -z "$up2date" ]; then
			$ECHO "   FAILED" >&2
			error "There was no output!"
			exit 1
	else
		if [ "$pkgver" != "$up2date" ]; then
			$ECHO "   FAILED" >&2
                       error "Upstream version differs! ($pkgver != $up2date)"
			exit 1
		else
		$ECHO "   Passed" >&2
		fi
	fi
fi

# estimate build time
if grep -i -q "^# Compiling Time: [~0-9\.]\+ SBU$" $BUILDSCRIPT && \
	[ ! -z "$SBU" ] && [ "$SBU" != "1" ]; then
	pkgsbu=`grep -i "^# Compiling time: [~0-9\.]\+ SBU$" $BUILDSCRIPT|sed 's/^# Compiling [Tt]ime: ~*\([0-9\.]\+\) SBU$/\1/'`
	if [ ! "`type -p bc`" ]; then
		warning "Cannot find the bc binary! Is bc installed? Skipping calculating the estimated build time."
	else
		secs=`$ECHO "$pkgsbu*$SBU"|bc /dev/stdin|sed 's/\.[0-9]*$//'`
		[ -z "$secs" ] && secs=0
		if [ $secs -ge 3600 ]; then
			hrs=`$ECHO $(($secs/3600))`
			secs=`$ECHO $(($secs%3600))`
			mins=`$ECHO $(($secs/60))`
			secs=`$ECHO $(($secs%60))`
		elif [ $secs -ge 60 ]; then
			mins=`$ECHO $(($secs/60))`
			secs=`$ECHO $(($secs%60))`
		fi
		if [ ! -z "$hrs" ]; then
			[ $hrs -gt 1 ] && hrs="$hrs hours " || hrs="$hrs hour "
		fi
		if [ ! -z "$mins" ]; then
			[ $mins -gt 1 ] && mins="$mins minutes " || mins="$mins minute "
		fi
		if [ ! -z "$secs" ]; then
			[ $secs -gt 1 ] && secs="$secs seconds " || secs="$secs second "
		fi
		msg "Estimated build time: $hrs$mins$secs"
	fi
fi

if [ "`check_option NOASNEEDED`" ]; then
	msg "Using --no-as-needed in LDFLAGS"
	LDFLAGS+=" -Wl,--no-as-needed"
else
	if [ "`check_option ASNEEDED`" ]; then
		msg "Using --as-needed in LDFLAGS"
		LDFLAGS+=" -Wl,--as-needed"
	fi
fi
export LDFLAGS

# retrieve sources
msg "Retrieving Sources..."
mkdir -p src
cd $startdir/src
for netfile in "${source[@]}" "${signatures[@]}"; do
	[ -z "$netfile" ] && continue
	file=`strip_url "$netfile"`
	if [ -f "../$file" ]; then
		msg2 "Found $file in build dir"
		cp "../$file" .
	elif [ -f "/var/cache/pacman-g2/src/$file" ]; then
		msg2 "Using local copy of $file"
		cp "/var/cache/pacman-g2/src/$file" .
	else
		proto=`$ECHO "$netfile" | sed 's|://.*||'`
		if [ "$proto" != "ftp" -a "$proto" != "http" -a "$proto" != "https" ]; then
			error "$netfile was not found in the build directory and is not a proper URL."
			msg "Aborting..."
			exit 1
		fi
		# try to download the file from the cache server
		if [ -n "$RSYNCAGENT" -a -n "$CACHEURL" ]; then
			# check if the file is there
			eval $RSYNCAGENT $CACHEURL/${file//;/\\\;} &>/dev/null
			if [ "$?" = "0" ]; then
				eval $RSYNCAGENT $CACHEURL/${file//;/\\\;} ./
				if [ ! -f "$file" ]; then
					error "Failed to download $file from cache while it is there"
					msg "Aborting..."
					exit 1
				fi
			fi
		fi
		# if failed to retreive from cache download it from the master server
		if [ ! -f "$file" ]; then
			msg2 "Downloading $file"
			$FTPAGENT "$netfile" 2>&1
			if [ ! -f "$file" ]; then
				error "Failed to download $file"
				msg "Aborting..."
				exit 1
			fi
		fi
		if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
			mkdir -p /var/cache/pacman-g2/src && cp "$file" /var/cache/pacman-g2/src
		else
			cp "$file" ..
		fi
	fi
done

if [ "$GENSHA1" = "0" ]; then
	if [ "$NOEXTRACT" = "1" ]; then
		warning "Skipping source extraction       -- using existing src/ tree"
		warning "Skipping source integrity checks -- using existing src/ tree"
	else
		# SHA1 validation
		if [ ${#sha1sums[@]} -eq ${#source[@]} ]; then
			if [ `type -p sha1sum` ]; then
				msg "Validating source files with SHA1sums"
				errors=0
				idx=0
				for netfile in "${source[@]}"; do
					file=`strip_url "$netfile"`
					$ECHO -n "    $file ... " >&2
					$ECHO "${sha1sums[$idx]}  $file" | sha1sum -c - >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						$ECHO "FAILED" >&2
						errors=1
					else
						$ECHO "Passed" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The sha1sum program is missing.  Cannot verify source files!"
				sleep 1
			fi
		fi
		# gpg validation
		if [ ${#signatures[@]} -eq ${#source[@]} ]; then
			if [ `type -p gpg` ]; then
				if [ ! -d ~/.gnupg ]; then
					msg "Configuring gpg..."
					gpg --list-keys
					$ECHO "keyserver-options auto-key-retrieve" >>~/.gnupg/gpg.conf
				fi
				if [ -e $startdir/$pkgname.key ]; then
					msg "Importing $pkgname.key"
					gpg --import $startdir/$pkgname.key
				fi
				msg "Validating source files with gpg"
				errors=0
				idx=0
				for netfile in "${source[@]}"; do
					file=`strip_url "$netfile"`
					sig=`strip_url "${signatures[$idx]}"`
					$ECHO -n "    $file ... " >&2
					if [ ! -z "$sig" ]; then
						echo "$sig" | grep -q "^$file" >/dev/null 2>&1
						if [ $? -ne 0 ]; then
							case $file in
								*.gz)  cmd='zcat'  ;;
								*.bz2) cmd='bzcat' ;;
								*.xz)  cmd='xzcat' ;;
							esac
						else
							cmd='cat'
						fi
						$cmd $file | gpg --batch --verify $sig - >/dev/null 2>&1
						if [ $? -ne 0 ]; then
							$ECHO "FAILED" >&2
							errors=1
						else
							$ECHO "Passed" >&2
						fi
					else
						$ECHO "Skipping" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The gpg program is missing.  Cannot verify source files!"
				sleep 1
			fi
		fi

		# extract sources
		msg "Extracting Sources..."
		for netfile in "${source[@]}"; do
			unziphack=0
			file=$(strip_url $netfile)
			Fextract "${file}"
		done
	fi
else
	# this condition is always true, but leave it here in case in the
	# future we want to add support for other hash algorithms
	if [ "$GENSHA1" = "1" ]; then
		if [ ! `type -p sha1sum` ]; then
			error "Cannot find the sha1sum program."
			exit 1
		fi
		msg "Generating SHA1sums for source files"
		plain ""
		ct=0
		newline=0
		numsrc=${#source[@]}
		for netfile in ${source[@]}; do
			file=$(strip_url $netfile)
			sum=$(sha1sum $file | cut -d' ' -f 1)
			if [ $ct -eq 0 ]; then
				SHA1SUMS="sha1sums=("
			else
				SHA1SUMS="${SHA1SUMS}"
			fi
			SHA1SUMS="${SHA1SUMS}'${sum}'"
			ct=$(($ct+1))
			if [ $ct -eq $numsrc ]; then
				SHA1SUMS="${SHA1SUMS})"
			else
				# Don't be afraid but \\\n instead of \n coz of the \\ a little below
				# \\\n would give \n (printed) but \\\\\n will give \
				# and a new line carriage '\n' (i.e '\''\n')
				SHA1SUMS="${SHA1SUMS} \\\\\n          "
			fi
		done
		$ECHO -e "${SHA1SUMS}"
		plain ""
		if [ "${WRITESHA1}" = 1 ]; then
			cd ${startdir}
			if [ "`grep -c sha1sums= ${BUILDSCRIPT}`" -gt 1 ]; then
				error "${BUILDSCRIPT} contain more than one sha1sums, please update manually"
				exit 1
			fi
			if grep -q sha1sums= ${BUILDSCRIPT}; then
				msg "Updating \$sha1sums() in the $BUILDSCRIPT."
				# remove the sha1sum lines except the first and
				# the last one. hopefully the regexp is complex
				# enough that we won't remove something
				# unrelated
				sed "/\t\? \+'[a-z0-9]\{40\}' \?\\\\/d" -i $BUILDSCRIPT
				# doing this in one step causes sed hang. maybe this is a sed bug?
				sed -e :a -e "\$!N;s/sha1sums=(.*)/MAKEPKG_$$/;ta;P;D" -i $BUILDSCRIPT
				sed "s/MAKEPKG_$$/$SHA1SUMS/" -i $BUILDSCRIPT
			else
				warning "Initial \$sha1sums() array does not exist, Aborting..."
			fi
		fi
		exit 0
	fi
fi

if [ "`id -u`" = "0" ]; then
	# chown all source files to root.root
	chown -R root.root $startdir/src
fi

# check for existing pkg directory
if [ -d $startdir/pkg ]; then
	msg "Removing existing pkg and pkg.* directories..."
	rm -rf $startdir/{pkg,pkg.*}
fi
mkdir -p $startdir/pkg
for subpkg in "${subpkgs[@]}"
do
	mkdir -p $startdir/pkg.$subpkg
done

if [ "$NOBUILD" = "1" ]; then
	msg "Sources are ready."
	exit 0
fi

# use distcc if requested
if [ "$DISTCC" = "y" -a -d /usr/lib/distcc/bin ]; then
	export PATH=/usr/lib/distcc/bin:$PATH
	FCC="distcc $FCC"
	if [ "$INCHROOT" = "1" ]; then
		[ -d /var/tmp/fst/.distcc ] || mkdir /var/tmp/fst/.distcc
		export DISTCC_DIR=/var/tmp/fst/.distcc
	fi
fi

# use ccache if it's available
if [ "$NOCCACHE" = "0" -a -d /usr/lib/ccache/bin -a ! "`check_option NOCCACHE`" ]; then
	if [ "$CHROOT" = "1" ]; then
		CCACHE_REALDIR=/var/cache/ccache
	else
		CCACHE_REALDIR=$CCACHE_BASEDIR
	fi
	if [ -w $CCACHE_REALDIR ]; then
		export PATH=/usr/lib/ccache/bin:$PATH
		FCC="ccache $FCC"
		install -d -m 2775 $CCACHE_REALDIR/$pkgname
		export CCACHE_DIR=$CCACHE_REALDIR/$pkgname
		export CCACHE_NOLINK=1
		export CCACHE_UMASK=002
	else
		if [ "$INCHROOT" != "1" ]; then
			error "You installed ccache but you are not in the ccache group."
			plain "Either add yourserlf to the ccache group or"
			plain "use the -B option to disable ccache support."
			exit 1
		else
			warning "The fst user is not in the ccache group, ccache will be disabled."
		fi
	fi
fi

# build
msg "Starting build()..."
stime=`date +%s`
build
if [ $? -gt 0 ]; then
	error "Build Failed.  Aborting..."
	exit 2
fi

if [ -n "`find . -name "*|*"`" ]; then
	error "Filenames in a package must not contain pipes!"
	exit 2
fi

# count sbu
if [ "$SBU" == "1" ]; then
	# $SBU not yet set
	totaltime="$(( $(date +%s) - $stime ))"
	if [ -z "$HRBT" ]; then 
		msg "Elapsed Time: $totaltime seconds"
	else
		hours="$(( $totaltime / 3600 ))"
		minutes="$(( $totaltime % 3600 / 60 ))"
		seconds="$(( $totaltime % 3600 % 60 ))"
		totaltime=""
		if [ "$hours" -gt 0 ]; then
			totaltime="$totaltime ${hours}h"
		fi
		if [ "$minutes" -gt 0 ]; then
			totaltime="$totaltime ${minutes}m"
		fi
		if [ "$seconds" -gt 0 ]; then
			totaltime="$totaltime ${seconds}s"
		fi
		msg "Elapsed Time:$totaltime"
	fi
elif [ ! -z "$SBU" ]; then
	if [ `type -p bc` ]; then
		pkgsbu=`$ECHO -e "scale=2\n$(($(date +%s)-$stime))/$SBU"|bc /dev/stdin|sed 's/^\./0./'`
		msg "Elapsed Time: $pkgsbu SBU"
	else
		warning "The bc program is missing.  Cannot count SBU!"
	fi
fi

cd $startdir

# unwanted files
msg "Removing unwanted files..."
extra=
ls pkg.* &>/dev/null && extra=pkg.*/usr/lib/perl?
for f in `find pkg/usr/lib/perl? $extra -type f 2> /dev/null` ; do
	case "$f" in
		*/.packlist|*/perllocal.pod)
			rm -f "$f"
			rmdir -p --ignore-fail-on-non-empty `dirname $f` 2> /dev/null
		;;
	esac
done
extra=
ls pkg.* &>/dev/null && extra=pkg.*
rm -f {pkg,pkg.*}/{usr{,/local,/share},opt/*}/info/dir 2> /dev/null
for f in `find pkg $extra -type f -name encodings.dir -o -type f -name fonts.dir -o -type f -name fonts.scale` ; do
	msg2 "`$ECHO $f | sed 's|pkg[^/]\+||'`"
	rm -f "$f"
done

# documentation
msg "Preparing package documentation..."
if [ ! "`check_option NODOCS`" -a "$NODOCS" = "0" ]; then
	mkdir -p pkg/usr/share/doc/$pkgname-$pkgver
	find src -maxdepth 2 -size +0b \( \
		    -name ANNOUNCE \
		-or -name AUTHORS \
	  	-or -name '*BUGS*' \
		-or -name CHANGES \
		-or -name CONFIGURATION \
		-or -name '*COPYING*' \
		-or -name '*COPYRIGHT*' \
		-or -name CREDITS \
		-or -name ChangeLog \
		-or -name Changelog \
		-or -name CHANGELOG \
		-or -name CONTRIBUTORS \
		-or -name '*FAQ*' \
		-or -name FEATURES \
		-or -name FILES \
		-or -name HACKING \
		-or -name History \
		-or -name HISTORY \
		-or -name 'INSTALL*' \
		-or -name LICENSE \
		-or -name LSM \
		-or -name MANIFEST \
		-or -name NEWS \
		-or -name '*README*' \
		-or -name '*Readme*' \
		-or -name SITES \
		-or -name '*RELEASE*' \
		-or -name RELNOTES \
		-or -name THANKS \
		-or -name TIPS \
		-or -name TODO \
		-or -name VERSION \
		-or -name 'CONFIGURATION*' \
		-or -name GPLLicense \
		\) -exec install -pm 644 '{}' pkg/usr/share/doc/$pkgname-$pkgver/ \;
fi
for d in $startdir/{pkg,pkg.*}
do
	[ ! -d $d ] && continue
	if [ -d $d/usr/doc ]; then
		if [ ! "`check_option NODOCS`" -a "$NODOCS" = "0" ]; then
			mkdir -p $d/usr/share/doc/$pkgname-$pkgver
			cp -a $d/usr/doc/* $d/usr/share/doc/$pkgname-$pkgver
		fi
		rm -rf $d/usr/doc
	fi

	# remove /usr/share/doc/$pkgname-$pkgver directory if empty
	if [ -d $d/usr/share/doc/$pkgname-$pkgver ]; then
		rmdir -p --ignore-fail-on-non-empty $d/usr/share/doc/$pkgname-$pkgver 2> /dev/null
		mkdir -p pkg
	fi

	# move /usr/info files to /usr/share/info
	if [ -d $d/usr/info ]; then
		mkdir -p $d/usr/share/info
		cp -a $d/usr/info/* $d/usr/share/info/
		rm -rf $d/usr/info
	fi

	# move /usr/man files to /usr/share/man
	if [ -d $d/usr/man ]; then
		mkdir -p $d/usr/share/man
		cp -a $d/usr/man/* $d/usr/share/man/
		rm -rf $d/usr/man
	fi

	if [ -d "$d/usr/share/icons/hicolor" ]; then
		if [ -z "$_F_gnome_iconcache" ]; then
			warning "Package $pkgname contains hicolor icons but _F_gnome_iconcache is not set"
		fi
	fi
done

# compress info and manual pages
msg "Compressing info and manual pages..."
find $startdir/{pkg,pkg.*}/{usr{,/local,/share},opt/*}/{info,man} -type f 2>/dev/null | while read i ; do
	ext="${i##*.}"
	fn="${i##*/}"
	if [ "$ext" != "gz" -a "$ext" != "bz2" ]; then
		# update symlinks to this manpage
		find $startdir/{pkg,pkg.*}/{usr{,/local,/share},opt/*}/man -lname "$fn" 2> /dev/null | while read ln ; do
			rm -f "$ln"
			ln -sf "${fn}.gz" "${ln}.gz"
		done
		# compress the original
		gzip -9 "$i"
	fi
done

# check symbolic links
msg "Checking symbolic links..."
for d in $startdir/{pkg,pkg.*} ; do
	for l in `find $d -type l 2> /dev/null` ; do
		if [ ! -e "$l" -a ! -e "$d/`ls -l $l | awk '{print $NF}'`" ]; then
			if [ "$d" = "$startdir/pkg" ]; then
				msg2 "Maybe broken link ${l#$d} in pkg $pkgname found."
			else
				msg2 "Maybe broken link ${l#$d} in pkg ${d##*/pkg.} found."
			fi
		elif ls -l "$l" | awk '{print $NF}' | grep -q "$startdir" ; then
			if [ "$d" = "$startdir/pkg" ]; then
				msg2 "Broken link ${l#$d} in pkg $pkgname found."
			else
				msg2 "Broken link ${l#$d} in pkg ${d##*/pkg.} found."
			fi
		fi
	done
done

# strip binaries
strip_pkg $pkgname
if [ -n "$subpkgs" ]; then
	i=0
	for subpkg in "${subpkgs[@]}"
	do
		unset options
		options="${suboptions[$i]}"
		strip_pkg $subpkg
		i=$(($i+1))
	done
fi

# get some package meta info
builddate=`LC_ALL= ; LANG= ; date -u "+%a %b %e %H:%M:%S %Y"`
if [ "$INCHROOT" != "1" ]; then
	buildtype="custom"
else
	buildtype="chroot"
fi

create_pkg $pkgname
if [ ! -z "$subpkgs" ]; then
	i=0
	for subpkg in "${subpkgs[@]}"
	do
		unset pkgdesc license replaces groups depends rodepends removes conflicts provides backup install
		unset options pkgdesc_localized archs
		pkgdesc="${subdescs[$i]}"
		pkgdesc_localized="${subdescs_localized[$i]}"
		license="${sublicense[$i]}"
		replaces="${subreplaces[$i]}"
		groups="${subgroups[$i]}"
		depends="${subdepends[$i]}"
		rodepends="${subrodepends[$i]}"
		removes="${subremoves[$i]}"
		conflicts="${subconflicts[$i]}"
		provides="${subprovides[$i]}"
		backup="${subbackup[$i]}"
		install="${subinstall[$i]}"
		options="${suboptions[$i]}"
		archs="${subarchs[$i]}"
		if in_array $CARCH ${archs[@]}; then
			create_pkg $subpkg
		fi
		i=$(($i+1))
	done
fi

cd $startdir
if [ "$CLEANUP" = "1" ]; then
	if [ "$INCHROOT" == "1" ]; then
		exclude="--exclude=/proc --exclude=/sys --exclude=/dev"
		exclude="$exclude --exclude=/var/cache/pacman-g2 --exclude=/var/cache/ccache/$pkgname"
		msg "Chroot size before cleaning: $(sudo du -sh $exclude / |sed "s/\t.*//")"
	fi
	msg "Cleaning up..."
	rm -rf src pkg pkg.* Changelog
fi

if [ "$RMDEPS" = "1" -a "`id -u`" = "0" -a "$INFAKEROOT" != "1" -a \( ! -z "$deplist" -o ! -z "$makedeplist" \) ]; then
	msg "Removing installed dependencies..."
	$PACMAN $PACMAN_OPTS -R $makedeplist $deplist
elif [ "$RMDEPS" = "1" -a "$DEP_SUDO" = "1" ]; then
	msg "Removing installed dependencies..."
	if [ "$INFAKEROOT" = "1" ]; then
		FAKEROOTKEY2=$FAKEROOTKEY
		unset FAKEROOTKEY
	fi
	sudo $PACMAN $PACMAN_OPTS -R $makedeplist $deplist
	if [ "$INFAKEROOT" = "1" ]; then
		export FAKEROOTKEY=$FAKEROOTKEY2
		unset FAKEROOTKEY2
	fi
fi

msg "Finished making: $pkgname  (`date`)"

install_pkg

exit 0
